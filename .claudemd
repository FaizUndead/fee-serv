# Fee Server - Technical Context

## Project Overview

This is a TypeScript-based Node.js server built with Fastify for managing fee configurations. The server accepts CSV file uploads containing fee rules, validates them, and stores them in-memory for use by other application logic.

## Architecture & Design Decisions

### TDD Approach

The entire project was built using Test-Driven Development:
1. Types and interfaces defined first
2. Tests written before implementation
3. Implementation created to make tests pass
4. Code refactored while maintaining green tests

This approach ensured:
- High test coverage (19 tests across 4 test suites)
- Clear specification of behavior before coding
- Confidence in refactoring

### Separation of Concerns

**Controllers** (`src/controllers/`)
- Thin layer handling HTTP request/response
- Orchestrates service calls
- Handles error responses and status codes
- No business logic

**Services** (`src/services/`)
- `csv-parser.ts`: Validates and parses CSV content into typed config
- `config-store.ts`: Simple in-memory storage for fee configuration
- Pure business logic with no HTTP concerns
- Independently testable

**Types** (`src/types/`)
- `FeeRule`: Single fee rule with feeType, from, to, percentage
- `FeeConfig`: Array of FeeRule objects
- Shared across all layers

### Technology Choices

**Fastify**
- Chosen for performance and TypeScript-first design
- Plugin architecture (@fastify/multipart for file uploads)
- Built-in validation and serialization support

**csv-parse**
- Robust CSV parsing with synchronous API
- Column-based parsing for easy validation
- Handles edge cases and malformed data

**TypeScript Strict Mode**
- All strict flags enabled in tsconfig.json
- Catches errors at compile time
- Better IDE support and refactoring confidence

**Jest with ts-jest**
- Standard testing framework for TypeScript
- Fast test execution
- Good mocking and assertion capabilities

## Current Implementation Status

### Completed Features

✅ Project setup with TypeScript, Jest, Fastify
✅ Health check endpoint (GET /health)
✅ CSV parser with validation (11 test cases)
  - Header validation
  - Data type validation
  - Range validation (percentage 0-1)
  - Error handling
✅ In-memory config store (3 test cases)
  - Set and get operations
  - Config overwriting
✅ File upload endpoint (POST /fee)
  - Multipart file handling
  - CSV parsing integration
  - Config storage integration
  - Error responses (3 controller test cases)
✅ Comprehensive test suite (19 total tests)
✅ Documentation (README.md)

### Not Yet Implemented

- Fee calculation logic (deliberately deferred per requirements)
- Config retrieval endpoint (GET /fee)
- Data persistence (currently in-memory only)
- Authentication/authorization
- Rate limiting
- Request validation schemas
- Logging improvements
- Error monitoring

## Code Organization Patterns

### File Naming
- `*.ts` - Implementation files
- `*.test.ts` - Test files (colocated with implementation)
- `*.types.ts` - Type definition files

### Test Organization
- Each service/controller has its own test file
- Tests are colocated with the code they test
- Server-level tests only cover routing and health endpoint
- Controller tests verify HTTP integration
- Service tests verify business logic in isolation

### Import Strategy
- Relative imports within the same module
- Absolute imports avoided (project is small enough)
- Types imported from dedicated type files

## Memory Considerations

The config store uses a simple module-level variable:
```typescript
let feeConfig: FeeConfig | undefined;
```

**Implications**:
- Config is lost on server restart
- Not suitable for multi-instance deployments without external storage
- Fast read/write with no I/O overhead
- Good for prototyping and development

**Future Options**:
- Add Redis for shared in-memory storage
- Add database persistence (PostgreSQL, MongoDB)
- Add file-based persistence as fallback

## Testing Strategy

### Unit Tests (Services)
- csv-parser: 11 tests covering parsing, validation, edge cases
- config-store: 3 tests covering get/set/overwrite operations
- Isolated from HTTP layer and file I/O

### Integration Tests (Controllers)
- fee.controller: 3 tests covering file upload, parsing, and storage integration
- Tests actual HTTP requests using Fastify's inject method
- Verifies end-to-end flow without network calls

### Server Tests
- 2 tests for health endpoint
- Minimal coverage as routing is handled by Fastify

### Test Utilities
- FormData used for multipart file upload testing
- Fastify inject() for HTTP testing without starting server
- Test isolation maintained (each test suite has own server instance)

## Development Workflow

1. **Start development server**: `npm run dev`
   - Uses ts-node-dev for hot reload
   - Automatic restart on file changes

2. **Run tests during development**: `npm run test:watch`
   - Jest watch mode
   - Re-runs tests on file changes

3. **Build for production**: `npm run build`
   - Compiles TypeScript to JavaScript in `dist/`
   - Type checking and compilation errors caught

4. **Run production build**: `npm start`
   - Runs compiled JavaScript from `dist/`

## Future Considerations

### Immediate Next Steps
- Implement fee calculation logic using stored config
- Add endpoint to retrieve current config
- Add endpoint to calculate fees based on amount and type

### Scalability
- Move config storage to Redis or database
- Add caching layer for fee calculations
- Consider horizontal scaling with load balancer

### Observability
- Structured logging with pino (already included via Fastify)
- Error tracking (Sentry, Datadog)
- Metrics and monitoring
- Health check improvements (check config loaded, etc.)

### Security
- Add authentication (JWT, API keys)
- Add authorization (role-based access)
- Rate limiting on upload endpoint
- File size limits and validation
- CSV injection prevention

### Data Validation
- Consider using Fastify schemas for request validation
- Add Zod or similar for runtime type validation
- More comprehensive CSV validation (range overlaps, gaps, etc.)

## Key Files to Know

- `src/server.ts` - Server setup, plugin registration, route definitions
- `src/controllers/fee.controller.ts` - POST /fee endpoint implementation
- `src/services/csv-parser.ts` - CSV validation and parsing logic
- `src/services/config-store.ts` - In-memory storage implementation
- `src/types/fee.types.ts` - Core type definitions
- `jest.config.js` - Test configuration
- `tsconfig.json` - TypeScript compiler configuration
